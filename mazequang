#pragma config(Sensor, S1,     Eyes,           sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          Right,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ------------------------------ PROTOTYPES ---------------------------------------
void cheat_corners();
// ------------------------------ DATA STRUCTURES ---------------------------------------

// Struct in order to store position w/r/t row, col
typedef struct {
	int row;
	int col;
} Position;

// MAZE MAPPING
/////////////////
// north = 0
// east = 1;
// south = 2;
// west = 3;
/////////////////
typedef struct{
	int n_wall;
	int e_wall;
	int w_wall;
	int s_wall;
	char visited;
} Cell;

// ------------------------------ GLOBAL SHIT ---------------------------------------
const int START_ROW = 3;
const int START_COL = 5;
const int END_ROW = 1;
const int END_COL = 5;

const int MAZE_ROW_SIZE = 4;
const int MAZE_COL_SIZE = 6;
const int ARR_SIZE = 20;
int direction = 0;
int start_index = 0;

// These are for setting the target cell
Position start;
Position end;
Position current;

// Arrays for storing the positions
int start_to_end[ARR_SIZE];
int reverse[ARR_SIZE];

// Just to fill up the arrays
void fill_arrays() {
	for (int i = 0; i < ARR_SIZE; i++) {
		start_to_end[i] = -10;
		reverse[i] = -10;
	}
}

// Creating the actual maze
Cell maze[MAZE_ROW_SIZE][MAZE_COL_SIZE];

// ------------------------------ STORING WALLS ---------------------------------------
void store_west_wall() {
	for (int row = 0; row < MAZE_ROW_SIZE; row++) {
		// 3 represents the west wall is in direction 3, "west"
		maze[row][0].w_wall = 3;
	}
}

void store_east_wall() {
	for (int row = 0; row < MAZE_ROW_SIZE; row++) {
		maze[row][5].e_wall = 1;
	}
}
void store_north_wall() {
	for (int col = 0; col < MAZE_COL_SIZE; col++) {
		maze[0][col].n_wall = 0;
	}
}

void store_south_wall() {
	for (int col = 0; col < MAZE_COL_SIZE; col++) {
		maze[3][col].s_wall = 2;
	}
}

void store_outside_walls() {
	store_south_wall();
	store_east_wall();
	store_west_wall();
	store_north_wall();
}

// ------------------------------ ACTUAL ROBOT TURNS ---------------------------------------
void reset_motors() {
	resetMotorEncoder(Left);
	resetMotorEncoder(Right);
}

void turn_robot_left() {
	//setMotorTarget(Left, 90*8.891, -60);
	//setMotorTarget(Right, 90*8.89, 60);
	//setMotorTarget(Left, 90*8.91, -60);
	//setMotorTarget(Right, 90*8.91, 62);

	//setMotorTarget(Left, 90*8.91, -95);
	//setMotorTarget(Right, 90*9, 100);
	//waitUntilMotorStop(Left);
	//waitUntilMotorStop(Right);
	//reset_motors();
	//wait1Msec(100);
	setMotorSyncEncoder(Left, Right, 100, 90*8.956, 100);
	waitUntilMotorStop(Left);
	waitUntilMotorStop(Right);
		reset_motors();
	wait1Msec(100);
}

void turn_robot_right() {
	//setMotorTarget(Left, 90*8.956, 95);
	//setMotorTarget(Right, 90*8.956, -100);
	//waitUntilMotorStop(Left);
	//waitUntilMotorStop(Right);
	//reset_motors();
	//wait1Msec(100);
	setMotorSyncEncoder(Left, Right, -100, 90*8.956, 100);
	waitUntilMotorStop(Left);
	waitUntilMotorStop(Right);
		reset_motors();
	wait1Msec(100);
}

void turn_robot_uturn() {
	setMotorTarget(Left, 90*8.94*2, 97);
	setMotorTarget(Right, 90*8.94*2, -100);
	waitUntilMotorStop(Left);
	waitUntilMotorStop(Right);
	reset_motors();
	wait1Msec(100);
	//setMotorSyncEncoder(Left, Right, 100, 90*8.94*2, 100);
	//waitUntilMotorStop(Left);
	//waitUntilMotorStop(Right);
}

void move_robot_fwd_one_cell() {
	//setMotorTarget(Left, 90*21.5, 97);
	//setMotorTarget(Right, 90*21.5, 100);
	//waitUntilMotorStop(Left);
	//waitUntilMotorStop(Right);
	//reset_motors();
	//wait1Msec(100);
	setMotorSyncEncoder(Left, Right, 0, 90*21.5, 100);
	waitUntilMotorStop(Left);
	waitUntilMotorStop(Right);
	reset_motors();
	wait1Msec(100);
}

//void back_up() {
// setMotorTarget(Left, 40, -60);
// setMotorTarget(Right, 40, -60);
// waitUntilMotorStop(Left);
// waitUntilMotorStop(Right);
// reset_motors();
//}

// ------------------------------ DIRECTION AND POSIITON ---------------------------------------
void set_start_and_end_position() {
	start.row = START_ROW;
	start.col = START_COL;

	end.row = END_ROW;
	end.col = END_COL;

	current.row = start.row;
	current.col = start.col;
}

void update_current_position() {
	if (direction == 0) {
		current.row--;
		} else if (direction == 1) {
		current.col++;
		} else if (direction == 2) {
		current.row++;
		} else if (direction == 3) {
		current.col--;
	}
}

// This check ensures that it will face north to reset orientation
void check_and_modify_direction() {
	if (direction > 3) direction %= 4;
}

void set_cell_as_visited() {
	maze[current.row][current.col].visited = 'v';
}

void turn_left() {
	direction += 3;
	check_and_modify_direction();
	turn_robot_left();
}

void turn_right() {
	direction += 1;
	check_and_modify_direction();
	turn_robot_right();
}

void u_turn() {
	direction += 2;
	check_and_modify_direction();
	turn_robot_uturn();
}

// This function ensures that everytime we move forward
// we store the direction we MOVED into the array
void store_movement_in_array() {
	start_to_end[start_index] = direction;
	start_index++;
}

// This should also store a position in the array when it moves
void move_fwd_one_cell() {
	// First set the cell it's leaving, as visited
	set_cell_as_visited();

	// Then move the robot after we've set the cell we've left as visited
	move_robot_fwd_one_cell();

	// After we move, should update our current position
	update_current_position();
}

// ------------------------------ MOVING ALGORITHM ---------------------------------------
bool getDistance() {
	if (getUSDistance(S1) < 10) return true;
	else return false;
}

void right_wall_follow() {
	// wall in front

	if ( (current.row == 0 && current.col == 0) || (current.row == 0 && current.col == 3) || (current.row == 0 && current.col == 5) || (current.row == 3 && current.col == 5)) {
		cheat_corners();
	}
	if (getDistance() == true) {
		turn_right();
	}
	else {
		store_movement_in_array();
		move_fwd_one_cell();
		cheat_corners();
		if (getDistance() != true) {
			turn_right();
			if (getDistance() == true) {
				turn_left();
			}
		}
		return;
	}
	// corner
	if (getDistance() == true) {
		u_turn();
		} else {
		store_movement_in_array();
		move_fwd_one_cell();
		cheat_corners();
		if (getDistance() != true) {
			turn_right();
			if (getDistance() == true) {
				turn_left();
			}
		}
		return;
	}
	// full surround
	if (getDistance() == true) {
		turn_left();
	}
}
// ----------------- MANIPULATING ARRAY FOR SHORTEST WAY BACK ---------------------------------------

// This function should replace North (0) and South (2) ||  East(1) and West(3)
// and store it in another array
void reverse_directions_in_array() {
	int begin = 0;
	for (int i = ARR_SIZE - 1; i >= 0; i--) {
		if (start_to_end[i] == 0) {
			reverse[begin] = 2;
		}
		else if (start_to_end[i] == 1) {
			reverse[begin] = 3;
		}
		else if (start_to_end[i] == 2) {
			reverse[begin] = 0;
		}
		else if (start_to_end[i] == 3) {
			reverse[begin] = 1;
		}
		begin++;
	}
}

// This replaces opposite directions with -10, and we always skip -10 values because
// it's not a direction
void store_shortest_path() {
	for (int i = 0; i < ARR_SIZE - 1; i++) {
		int j = i+1;
		while (reverse[j] == -10) {
			j++;
		}
		if (abs(reverse[i] - reverse[j]) == 2) {
			reverse[i] = -10;
			reverse[j] = -10;
			i-=2;
		}
	}
	//int i = 0;
	//while (i < ARR_SIZE) {
	//	int j= i+1;
	//	while (reverse[j] == -10) {
	//		j++
	//	}
	//	if (abs(reverse[i] - reverse[j]) == 2) {
	//		reverse[i] = -10;
	//		reverse[i + 1] = -10;
	//		i++;
	//		i-=2;
	//	}
	//}
}

void travel_the_shortest_path() {
	// Shortest path algorithm
	for (int i = 0; i < ARR_SIZE; i++) {
		// Wants to go north
		if (reverse[i] == 0) {
			if (direction == 0) {
				move_fwd_one_cell();
			}
			else if (direction == 1) {
				turn_left();
				move_fwd_one_cell();
			}
			else if (direction == 2) {
				u_turn();
				move_fwd_one_cell();
			}
			else if (direction == 3) {
				turn_right();
				move_fwd_one_cell();
			}
		}
		// Wants to go east
		if (reverse[i] == 1) {
			if (direction == 0) {
				turn_right();
				move_fwd_one_cell();
			}
			else if (direction == 1) {
				move_fwd_one_cell();
			}
			else if (direction == 2) {
				turn_left();
				move_fwd_one_cell();
			}
			else if (direction == 3) {
				u_turn();
				move_fwd_one_cell();
			}
		}
		// Wants to go south
		if (reverse[i] == 2) {
			if (direction == 0) {
				u_turn();
				move_fwd_one_cell();
			}
			else if (direction == 1) {
				turn_right();
				move_fwd_one_cell();
			}
			else if (direction == 2) {
				move_fwd_one_cell();
			}
			else if (direction == 3) {
				turn_left();
				move_fwd_one_cell();
			}
		}
		// Wants to go west
		if (reverse[i] == 3) {
			if (direction == 0) {
				turn_left();
				move_fwd_one_cell();
			}
			else if (direction == 1) {
				u_turn();
				move_fwd_one_cell();
			}
			else if (direction == 2) {
				turn_right();
				move_fwd_one_cell();
			}
			else if (direction == 3) {
				move_fwd_one_cell();
			}
		}
	}
}
// ---------------------------------- ------------ ---------------------------------------
// ---------------------------------- OPTIMIZATION ---------------------------------------
// ---------------------------------- ------------ ---------------------------------------

// ---------------------------------- CORNERS ---------------------------------------
void cheat_corners() {
	// Top left corner
	if (current.row == 0 && current.col == 0) {
		if (direction == 3) {
			u_turn();
		} else if (direction == 0) {
			turn_right();
		}
	}
	else if (current.row == 3 && current.col == 0) {
		if (direction == 3) {
			u_turn();
		} else if (direction == 0) {
			turn_right();
		}
	}
	// Bottom right corner
	else if (current.row == 3 && current.col == 5) {
		if (direction == 1) {
			u_turn();
		} else if (direction == 0) {
			turn_left();
		} else if (direction == 2) {
			turn_right();
		}
	}
}

// ------------------------------ INTERFACE ---------------------------------------

void interface(int up, int down, int right, int left) {
	if (getButtonPress(buttonUp)) up+=1;
	if (getButtonPress(buttonDown)) down+=1;
	if (getButtonPress(buttonRight)) right+=1;
	if (getButtonPress(buttonLeft)) left+=1;

	// start
	drawRect(0, 110, 35, 88);
	displayBigStringAt(35/2, 105, "%d", up);
	drawRect(35, 110, 70, 88);
	displayBigStringAt(50, 105, "%d", down);
	// end
	drawRect(105, 110, 140, 88);
	displayBigStringAt(120, 105, "%d", right);
	drawRect(140, 110, 175, 88);
	displayBigStringAt(160, 105, "%d", left);
}

// ------------------------------ TASKS ---------------------------------------
task show_row_col() {
	while (true) {
		displayCenteredBigTextLine(1, "Row: %d", current.row);
		displayCenteredBigTextLine(3, "Col: %d", current.col);
		displayCenteredBigTextLine(6, "Directon: %d", direction);
	}
}

// ------------------------------ MAIN ---------------------------------------
task main() {
	int up_counter = 0;
	int down_counter = 0;
	int left_counter = 0;
	int right_counter = 0;

	//while (true) {
	//	interface(up_counter, down_counter, left_counter, right_counter);
	//}
	startTask(show_row_col);

	fill_arrays();

	store_outside_walls();
	set_start_and_end_position();

	// Algorithm
	while(true) {
		right_wall_follow();

		// Reached the end point
		if (current.col == end.col && current.row == end.row) {
			playTone(100,100);
			break;
		}
	}
	// Displays the start_to_end array (directions from start to finish)
	displayCenteredTextLine(9, "%d, %d, %d, %d, %d, %d, %d, %d, %d", start_to_end[0], start_to_end[1], start_to_end[2], start_to_end[3], start_to_end[4], start_to_end[5], start_to_end[6], start_to_end[7]);

	// Algorithm is done, time to make our way back using the shortest path possible
	reverse_directions_in_array();

	// Displays the reversed array (start_to_end backwards)
	displayCenteredTextLine(11, "%d, %d, %d, %d, %d, %d, %d, %d, %d", reverse[0], reverse[1], reverse[2], reverse[3], reverse[4], reverse[5]);

	// Replace all cancelled things with -1
	store_shortest_path();

	// This should display the reversed array (Cancelling out opposite directions)
	displayCenteredTextLine(13, "%d, %d, %d, %d, %d, %d, %d, %d, %d", reverse[0], reverse[1], reverse[2], reverse[3], reverse[4], reverse[5]);

	// Make our way back to initial thing
	travel_the_shortest_path();
	playTone(100,100);

	//while(true) {
	//	turn_left();
	//}

}
